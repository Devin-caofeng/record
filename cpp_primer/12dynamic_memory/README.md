## ex12_1
- b1 包含4个元素
- b2 在代码的结尾被自动释放了，在被释放前也包含4个元素，且和 b1 相同

## [ex12_2](wx12_2.cpp)

## ex12_3
不需要，push_back 和 pop_back 会改变对象的内容。而 const 对象只读的，因此不需要

## ex12_4
因为 size_type 是无符号整型，当传递给 check 的参数小于0的时候，参数值会转换成一个正整数

## ex12_5
构造函数不是 explicit 的，意味着可以从 initializer_list 转换为 StrBlob。在 StrBlob
对象中，只用一个数据成员 data，而 StrBlob 对象本身的含义，也是一个**管理字符串的序列**。
因此，从 initializer_list 到 StrBlob 的转换在逻辑上是可行的，缺点是在某些地方我们
确实需要 initializer_list，而编译器仍然会将之转换为 StrBlob。

## [ex12_6](ex12_6.cpp)

## [ex12_7](ex12_7.cpp)

## ex12_8
此代码在函数内部动态申请了一个 int 大小的空间，然后把此空间的首地址做为了函数的
返回值，但是此函数的返回值类型为 bool，会导致地址丢失，以至于此代码在其他地方也
无法释放动态申请的那块内存，会导致内存泄露。

## ex12_9
- q 和 r 都指向 new int(42) 分配出内存的首地址，r 之前指向的那块动态申请的内存现在
  没有任何指针指向它，会导致那块内存泄露。
- q2 和 r2 都指向 make_shared<int>(42) 分配出的内存，r2 之前指向的那块内存现在的
  引用计数变为0，会被释放，r2 和 q2 由于指向同一块内存，所以其内部（智能指针）的
  引用计数都为2。
