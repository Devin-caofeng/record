## ex12_1
- b1 包含4个元素
- b2 在代码的结尾被自动释放了，在被释放前也包含4个元素，且和 b1 相同

## [ex12_2](ex12_2.cpp)

## ex12_3
不需要，push_back 和 pop_back 会改变对象的内容。而 const 对象只读的，因此不需要

## ex12_4
因为 size_type 是无符号整型，当传递给 check 的参数小于0的时候，参数值会转换成一个正整数

## ex12_5
构造函数不是 explicit 的，意味着可以从 initializer_list 转换为 StrBlob。在 StrBlob
对象中，只用一个数据成员 data，而 StrBlob 对象本身的含义，也是一个**管理字符串的序列**。
因此，从 initializer_list 到 StrBlob 的转换在逻辑上是可行的，缺点是在某些地方我们
确实需要 initializer_list，而编译器仍然会将之转换为 StrBlob。

## [ex12_6](ex12_6.cpp)

## [ex12_7](ex12_7.cpp)

## ex12_8
此代码在函数内部动态申请了一个 int 大小的空间，然后把此空间的首地址做为了函数的
返回值，但是此函数的返回值类型为 bool，会导致地址丢失，以至于此代码在其他地方也
无法释放动态申请的那块内存，会导致内存泄露。

## ex12_9
- q 和 r 都指向 new int(42) 分配出内存的首地址，r 之前指向的那块动态申请的内存现在
  没有任何指针指向它，会导致那块内存泄露。
- q2 和 r2 都指向 make_shared<int>(42) 分配出的内存，r2 之前指向的那块内存现在的
  引用计数变为0，会被释放，r2 和 q2 由于指向同一块内存，所以其内部（智能指针）的
  引用计数都为2。

## ex12_10
正确，`shared_ptr<int>(p)` 会创建一个临时的智能指针，这个智能指针与 p 引用一个对象，此时引用计数为 2.
当表达式结束时，临时的智能指针被销毁，此时引用计数变为 1。

## ex12_11
这样会创建一个新的智能指针，它的引用计数为 1，这个智能指针所指向的空间与 p 相同。在函数结束后，
这个临时智能指针会被销毁，引用计数为 0，所指向的内存空间也会被释放，而导致 p 所指向的空间被释放，
使得 p 成为一个野指针。

## ex12_12
- a，合法，将 sp 拷贝给 process 的形参，在进入函数后 sp 的引用计数加一，函数结束后
恢复原有的计数
- b，不合法，不能隐式的将内置指针转化为智能指针
- c，不合法，同上
- d，合法，但是智能指针和内置指针一起使用可能会出现问题，在函数结束后智能指针会被销毁，
  其所指的内存空间也会被释放，而此时内置指针 p 仍然指向该内存空间，之后对 p 的操作可能会
  引发一系列错误

## ex12_13
智能指针 sp 所指向的空间已经被 delete，再对 sp 进行操作会出现错误

## [ex12_14](ex12_14.cpp)

## [ex12_15](ex12_15.cpp)

## [ex12_16](ex12_16.cpp)

## ex12_17
- a，不合法，unique_ptr 需要一个从堆上创建的空间的地址作为参数
- b，合法，  但是当 p1 作用域结束后，会调用 delete 释放其指向的空间，但是 pi 是从栈上分配的，调用 delete 会导致出错
- c，合法，  当 p2 被销毁后，pi2 会称为空悬指针
- d，不合法，当 p3 被销毁时，它试图 delete 一个栈空间的对象
- e，合法
- f，不合法，会导致内存重复释放

## ex12_18
release 成员的作用是放弃控制权并返回指针，因为在某一时刻只能有一个 unique_ptr 指向某个对象，unique_ptr 不能被赋值，
所以要使用 release 成员将一个 unique_ptr 的指针的所有权传递给另一个 unique_ptr，而 shared_ptr 允许有多个 shared_ptr
指向同一个对象，所以不需要 release 成员

## ex12_19[headder](ex12_19.hpp)|[inplementation](ex12_19.cpp)

## [ex12_20](ex12_20.cpp)

## ex12_21
我认为原来的版本更好，因为原来的版本可读性更好一些

## ex12_22[headder](ex12_22.hpp)|[inplementation](ex12_22.cpp)

## [ex12_23](ex12_23.cpp)

## [ex12_24](ex12_24.cpp)

## ex12_25
`delete[] pa;`

## [ex12_26](ex12_26.cpp)
